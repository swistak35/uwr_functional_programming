<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
    <title>Programowanie funkcyjne</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
    <style type="text/css">
      body { font-family: sans-serif }
    </style>
  </head>
  <body>
    <table>
      <tbody>
	<tr>
	  <td>
	    <table cellpadding="20">
	      <tbody>
		<tr>
		  <td>
		    <b>Programowanie funkcyjne, II UWr, 2013/14<br>
		      Lista zadañ nr 5 </b> 
		  </td>
		</tr> 
	    </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ I (na 14.11.2013)
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 1 (4p.)</h4>
		    Zdefiniuj typ do reprezentacji leniwych nieskoñczonych ci±gów
		    elementów dowolnego typu (strumieni)
		    tak, jak na wyk³adzie. Nastêpnie:
		    <ul>
		      <li> zdefiniuj strumieñ przybli¿aj±cy warto¶æ
			liczby pi z rosn±c± dok³adno¶ci±, korzystaj±c
			ze wzoru Leibniza: &#960;<tt>/4 = 1 - 1/3 +
			1/5 - 1/7 + ... </tt>
		      </li>
		      <li> napisz funkcjê przekszta³caj±c± dowolny strumieñ <tt>x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,...</tt> 
			w strumieñ postaci
			<tt>f x<sub>1</sub> x<sub>2</sub> x<sub>3</sub>, 
			  f x<sub>2</sub> x<sub>3</sub> x<sub>4</sub>, f x<sub>3</sub> x<sub>4</sub> x<sub>5</sub>,...</tt>, 
			dla dowolnej funkcji f. 
		      </li>
		      <li> korzystaj±c z powy¿szych definicji i transformacji Eulera:<br>
			<tt>F x y z = z - (y-z)<sup>2</sup>/(x-2y+z)</tt><br>
			utwórz nowy strumieñ, szybciej zd±¿aj±cy do liczby &#960;.
		      </li>
		    </ul>
		    Napisz te same definicje u¿ywaj±c konstrukcji <tt>lazy </tt> i <tt>force </tt> z modu³u Lazy. Dlaczego
		    <tt>lazy </tt> jest specjaln± konstrukcj± jêzyka, a nie funkcj±?
		  </td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 2 (2p.)</h4>
		    Napisz funkcjê przeszukiwania zbioru stanów wszerz, typu 
		    <tt>('a -&gt; 'a list) -&gt; 'a -&gt; 'a llist</tt> (przy wybranej przez siebie reprezentacji list leniwych 
		    <tt>'a llist</tt>), a nastêpnie wykorzystaj j± do rozwi±zania problemu n hetmanów.
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ II (na 21.11.2013)
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 3 (2p.)</h4>  Zmodyfikuj zaproponowane
		    na wyk³adzie rozwi±zanie problemu n hetmanów, tak
		    by pozbyæ siê leniwej listy zawieraj±cej wszystkie
		    mo¿liwe ustawienia hetmanów, z której dopiero
		    wybiera siê rozwi±zania dobre. Algorytm, o który
		    chodzi wygl±da mniej wiêcej tak:
		    <ul>
		      <li>je¿eli bie¿±ce ustawienie jest rozwi±zaniem,
                          to zwróæ kolekcjê zawieraj±c± to rozwi±zanie;
		      </li><li>w przeciwnym razie, zsumuj kolekcje
			rozwi±zañ otrzymane przez dostawienie hetmana
			na wszystkie legalne pozycje w kolejnej
			kolumnie i powtórzenie algorytmu dla
			ka¿dego tak otrzymanego ustawienia.
		    </li></ul>
		  </td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 4 (6p.)</h4>
		    <a href="http://pl.wikipedia.org/wiki/Kodowanie_Huffmana">Kodowanie Huffmana</a> 
		    jest prost± metod± bezstratnej kompresji.
		    Za³ó¿my, ¿e dana jest lista asocjacyjna z³o¿ona z par (symbol, czêsto¶æ wystêpowania).
		    Zaimplementuj statyczny algorytm kodowania i dekodowania napisów (czyli ci±gów symboli z listy) 
		    wed³ug nastêpuj±cych zasad:
		    <ul>
		      <li>
			Drzewo kodowe jest drzewem binarnym, w którego li¶ciach znajduj±
			siê symbole wraz z ich czêsto¶ciami, a w ka¿dym wê¼le znajduje siê suma
			czêsto¶ci poddrzew lewego i prawego. Zdefiniuj typ takich drzew.
		      </li>
		      <li>
			Korzystaj±c z listy czêsto¶ci zbuduj drzewo Huffmana: Maj±c dan±
			listê drzew, wybieramy z niej dwa drzewa o najmniejszych czêsto¶ciach
			(ten wybór nie musi byæ jednoznaczny).
			Usuwamy te drzewa z listy, ³±czymy je w jedno drzewo i wstawiamy do
			listy. Kontynuujemy a¿ do otrzymania listy jednoelementowej (czyli
			drzewa kodowego).
			Pocz±tkowa lista sk³ada siê z li¶ci otrzymanych z listy czêsto¶ci.
			£±czenie dwóch poddrzew polega na utworzeniu nowego drzewa
			o czêsto¶ci bêd±cej sum± czêsto¶ci obu poddrzew.
		      </li> 
		      <li>
			Kodem symbolu jest zapis ¶cie¿ki od korzenia drzewa kodowego do
			li¶cia zawieraj±cego ten symbol, gdzie ¶cie¿ka jest reprezentowana jako
			ci±g zer i jedynek, w którym 0 oznacza zej¶cie do lewego poddrzewa, a 1
			zej¶cie do prawego poddrzewa (lub na odwrót, ale jednakowo dla
			wszystkich symboli). Kod napisu to ci±g kodów wszystkich symboli tego
			napisu.
		      </li>
		      <li>
			Dekodowanie jest procesem odwrotnym: dla danego ci±gu zer i jedynek koduj±cego pewien napis,
			wêdrujemy po drzewie wed³ug kierunków zapisanych w kodzie, zaczynaj±c od korzenia. Gdy dotrzemy do li¶cia,
			odczytujemy umieszczony w nim symbol i odrzucamy wykorzystany dot±d fragment kodu. 
			Nastêpnie dla pozosta³ego fragmentu kodu wracamy do korzenia i odszukujemy kolejne symbole, a¿ 
			do wyczerpania kodu.
		      </li>
		    </ul>
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
      </tbody>
    </table>
  

</body></html>