<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
    <title>Programowanie funkcyjne</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
    <style type="text/css">
      body { font-family: sans-serif }
    </style>
  </head>
  <body>
    <table>
      <tbody>
	<tr>
	  <td>
	    <table cellpadding="20">
	      <tbody>
		<tr>
		  <td>
		    <b>Programowanie funkcyjne, II UWr, 2013/14<br>
		      Lista zadañ nr 6</b> 
		  </td>
		</tr> 
	    </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ I (na 21.11.2013)
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 1 (4p.)</h4>
		    <i>Samefringe Problem.</i> Definiujemy typ danych
		    do reprezentacji drzew binarnych przechowuj±cych
		    warto¶ci w li¶ciach:
		    <blockquote>
		      <tt>
		      type 'a btree = Leaf of 'a 
		                    | Node of 'a btree * 'a btree
		      </tt>
		    </blockquote>
		    Dwa drzewa binarne typu <tt>t btree</tt> maj±
		    jednakowe korony (zak³adamy, ¿e obiekty
		    typu <tt>t</tt> s± porównywalne), je¶li listy
		    utworzone przez odczytanie warto¶ci w ich li¶ciach
		    od lewej do prawej s± równe. Na przyk³ad drzewa
		    <blockquote>
		      <tt>
		      Node (Node (Leaf 1, 
		                  Leaf 2),
		            Leaf 3)
		      </tt>
		    </blockquote>		      
		    i
		    <blockquote>
		      <tt>
		      Node (Leaf 1, 
		            Node (Leaf 2, 
		                  Leaf 3))
		      </tt>
		    </blockquote>
		    maj± jednakowe korony, równe <tt>[1; 2; 3]</tt>.
		    <ol>
		      <li>
			Napisz funkcjê rozstrzygaj±c± czy dwa drzewa
			maj± jednakowe korony, bazuj±c bezpo¶rednio na
			definicji i nie dbaj±c o efektywno¶æ
			rozwi±zania.
		      </li>
		      <li>
			Wykorzystuj±c pojêcie odroczonego obliczenia,
			napisz efektywn± i czysto funkcyjn± wersjê
			funkcji <tt>samefringe</tt>, tj. tak±, która
			przerywa obliczenia w momencie napotkania
			pierwszej ró¿nicy miêdzy koronami
			drzew. Podpowied¼: nale¿y odraczaæ
			trawersowanie prawego poddrzewa.
		      </li>
		    </ol>
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ II (na 28.11.2013)
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 2 (4p.)</h4>  Definiujemy typ danych
		    do reprezentacji drzew binarnych przechowuj±cych
		    warto¶ci zarówno w wêz³ach jak i w li¶ciach:
		    <blockquote>
		      <tt>
		      type 'a btree = Leaf of 'a 
		                    | Node of 'a btree * 'a * 'a btree
		      </tt>
		    </blockquote>
		    <ol>
		      <li> Napisz funkcjê numeruj±c± wêz³y i
			li¶cie drzewa binarnego w kolejno¶ci
			przechodzenia go w g³±b (preorder). Na
			przyk³ad, tak ponumerowan± wersj± drzewa
			<blockquote>
			  <tt>Node (Node (Leaf 'a', 'b', Leaf 'c'), 'd', Leaf 'e')</tt>
			</blockquote>
			jest
			<blockquote>
			  <tt>Node (Node (Leaf 3, 2, Leaf 4), 1, Leaf 5)</tt>.
			</blockquote>
		      </li>		      
		      <li> Napisz funkcjê numeruj±c± wêz³y i
			li¶cie drzewa binarnego w kolejno¶ci
			przechodzenia go wszerz. Na przyk³ad, tak
			ponumerowan± wersj± drzewa
			<blockquote>
			  <tt>Node (Node (Leaf 'a', 'b', Leaf 'c'), 'd', Leaf 'e')</tt>
			</blockquote>
			jest
			<blockquote>
			  <tt>Node (Node (Leaf 4, 2, Leaf 5), 1, Leaf 3)</tt>.
			</blockquote>
			Podpowied¼: lasy numeruje siê ³atwiej ni¿ drzewa.
		      </li>
		    </ol>
		  </td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 3 (4p.)</h4> Tablica funkcyjna to
		    struktura danych, która podobnie jak tablica
		    imperatywna, pozwala na swobodny dostêp do swoich
		    sk³adowych (poprzez ich indeksy w
		    tablicy). Jednak¿e, w przeciwieñstwie do tablicy
		    imperatywnej, operacje modyfikuj±ce sk³adowe
		    tablicy funkcyjnej nie nadpisuj± istniej±cej
		    tablicy, a tworz± jej kopiê, przy czym oryginalna
		    kopia nadal istnieje i mo¿e byæ u¿ywana w dalszych
		    obliczeniach. Takie struktury sprawdzaj± siê
		    lepiej ni¿ tablice imperatywne np. w algorytmach
		    niedeterministycznych z nawrotami.
		    <br><br>
		    Rozwa¿my implementacjê tablic funkcyjnych za
		    pomoc± drzew binarnych postaci:
		    <blockquote>
		      <tt>
		      type 'a btree = Leaf | Node of 'a btree * 'a * 'a btree
		      </tt>
		    </blockquote>
		    Zak³adamy przy tym, ¿e drzewo reprezentuje tablicê
		    indeksowan± liczbami ca³kowitymi od 1 do n, a
		    ¶cie¿ka do sk³adowej o indeksie k, wyznaczona jest
		    przez seriê dzieleñ modulo 2, a¿ do osiagniêcia
		    warto¶ci 1, wg zasady: je¶li k mod 2 = 0, to
		    wybieramy lewego syna, a w przeciwnym razie -
		    prawego, a nastêpnie poszukujemy elementu o
		    indeksie k div 2. W przypadku drzew
		    zbalansowanych, a z takimi mamy tu do czynienia,
		    dostêp do k-tego elementu wymaga log k kroków.

		    <br><br> Zdefiniuj typ danych <tt>'a array</tt>
		    (wraz z drzewem warto przechowywaæ najwy¿szy
		    indeks w tablicy) oraz nastêpuj±ce operacje na
		    tablicach funkcyjnych:
		    <ul>
		      <li>
			<tt>aempty : 'a array</tt>, tablica pusta;
		      </li>
		      <li>
			<tt>asub : 'a array -&gt; int -&gt; 'a</tt>, pobranie sk³adowej o zadanym indeksie;
		      </li>
		      <li>
			<tt>aupdate : 'a array -&gt; int -&gt; 'a -&gt; 'a array</tt>, modyfikacja sk³adowej o zadanym indeksie;
		      </li>
		      <li>
			<tt>ahiext : 'a array -&gt; 'a -&gt; 'a array</tt>, rozszerzenie tablicy o jedn± sk³adow±;
		      </li>
		      <li>
			<tt>ahirem : 'a array -&gt; 'a array</tt>, usuniêcie sk³adowej o najwy¿szym indeksie.
		      </li>
		    </ul>
		  </td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 4 (2p.)</h4>
		    Chcemy w Ocamlu zdefiniowaæ funkcjê <tt>sprintf</tt> znan± z jêzyka C, tak by np.
		    <pre>		      sprintf "Ala ma %d kot%s." : int -&gt; string -&gt; string
		    </pre>
		    pozwala³o zdefiniowaæ funkcjê
		    <pre>		      fun n -&gt; sprintf "Ala ma %d kot%s." n (if n = 1 then "a" else if 1 &lt; n &amp; n &lt; 5 then "y" else "ów")
		    </pre>
		    Na pierwszy rzut oka wydaje siê, ¿e rozwi±zanie
		    tego zadania wymaga typów zale¿nych, poniewa¿ typ
		    funkcji <tt>sprintf</tt> zale¿y od jej pierwszego
		    argumentu. Okazuje siê jednak, ¿e polimorfizm
		    parametryczny wystarczy.

		    Dla uproszczenia za³ó¿my, ¿e format nie jest
		    zadany przez warto¶æ typu <tt>string</tt> (nie
		    chcemy zajmowaæ siê parsowaniem), ale przez
		    konkatenacjê nastêpuj±cych dyrektyw formatuj±cych:
		    <ul>
		      <li><tt>lit s</tt> - sta³a napisowa <tt>s</tt>
		      </li><li><tt>eol</tt> - koniec wiersza
		      </li><li><tt>inr</tt> - liczba typu <tt>int</tt>
		      </li><li><tt>flt</tt> - liczba typu <tt>float</tt>
		      </li><li><tt>str</tt> - napis typu <tt>string</tt>
		    </li></ul>
		    Zak³adaj±c, ¿e operatorem konkatenacji dyrektyw
		    jest <tt>++</tt>, powy¿szy przyk³ad mo¿e byæ
		    zapisany nastêpuj±co:
		    <pre>		      sprintf (lit "Ala ma " ++ inr ++ " kot" ++ str ++ lit ".") : int -&gt; string -&gt; string
		    </pre>
		    Zdefiniuj
		    funkcje <tt>lit</tt>, <tt>eol</tt>, <tt>inr</tt>, <tt>flt</tt>, <tt>str</tt>, <tt>++</tt>
		    oraz funkcjê <tt>sprintf</tt>.

		    Podpowied¼: dyrektywy powinny byæ funkcjami
		    transformuj±cymi kontynuacje, a
		    operator <tt>++</tt> to zwyczajne z³o¿enie takich
		    funkcji. Na przyk³ad <tt>inr</tt> powinien mieæ
		    typ <tt>(string -&gt; a) -&gt; string -&gt; (int -&gt; a)</tt>
		    (argumentem ma byæ kontynuacja oczekuj±ca napisu,
		    ale o nieokre¶lonym typie odpowiedzi, a wynikiem
		    ma byæ kontynuacja oczekuj±ca napisu, a nastêpnie
		    liczby ca³kowitej). Podobnie, typem <tt>eol</tt>
		    ma byæ <tt>(string -&gt; a) -&gt; string -&gt; a<tt>.
		  </tt></tt></td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 5 (6p.)</h4>
		    Przeanalizuj interpreter Prologa zamieszczony <a href="http://ii.uni.wroc.pl/%7Edabi/courses/PF13/prolog.ml">tutaj</a>. 
		    <ol>
		      <li>Zmieñ definicjê funkcji <code>run</code> (i
		      tylko tej funkcji) tak by interpreter liczy³ na
		      ile spsobów dany cel mo¿e byæ spe³niony przy
		      danym programie zamiast sprawdzaæ tylko czy mo¿e
		      byæ spe³niony. (W interpreterze pojawi siê
		      nieogonowe wywo³anie -- czy potrafisz
		      zmodyfikowaæ ca³y interpreter, tak by je
		      wyeliminowaæ?)
		      </li><li>Rozwa¿my typ danych do reprezentowania
		      wyra¿eñ regularnych:
			<pre>			  type regexp = 
			    | Atom of char
			    | And of regexp * regexp  (*  r<sub>1</sub>r<sub>2</sub>     *)
			    | Or of regexp * regexp   (*  r<sub>1</sub> | r<sub>2</sub>  *)
			    | Star of regexp          (*  r<sup>*</sup>  *)
			</pre>
			Bazuj±c na modelu obliczeñ z nawrotami przy
			u¿yciu kontynuacji sukcesu oraz kontynuacji
			pora¿ki, zaprezentowanym na przyk³adzie
			iterpretera Prologa, napisz funkcje
			<pre>			  match_regexp : regexp -&gt; char list -&gt; (char list -&gt; (unit -&gt; 'a) -&gt; 'a) -&gt; (unit -&gt; 'a) -&gt; 'a
			</pre>
		        oraz
			<pre>			  run : regexp -&gt; char list -&gt; bool
			</pre>
			które dla danego wyra¿enia regularnego
			implementuj± niedeterministyczny automat
			rozpoznaj±cy jêzyk opisany przez to wyra¿enie.
		  </li></ol></td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
      </tbody>
    </table>
  

</body></html>