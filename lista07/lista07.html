<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Programowanie funkcyjne</title>    
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
    <style type="text/css">
      body { font-family: sans-serif }
    </style></head><body>
    <table>
      <tbody>
	<tr>
	  <td>
	    <table cellpadding="20">
	      <tbody>
		<tr>
		  <td>
		    <b>Programowanie funkcyjne, II UWr, 2013/14<br>
		      Lista zadañ nr 7</b> 
		  </td>
		</tr> 
	    </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ I (na 28.11.2013)
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 1 (4p.)</h4>  
		    <ol>
		      <li> Zdefiniuj operator
			sta³opunktowy <tt>fix</tt>
			typu <tt>(('a-&gt;'b)-&gt;'a-&gt;'b)-&gt;'a-&gt;'b</tt>,
			który pozwoli na wyznaczanie punktu sta³ego
			funkcji typu <tt>('a-&gt;'b)-&gt;'a-&gt;'b)</tt>, a co
			za tym idzie na definiowanie rekurencyjnych
			funkcji bez u¿ycia konstrukcji <tt>let
			rec</tt>. Np. silniê mo¿na wyraziæ przy
			u¿yciu <tt>fix</tt> nastêpuj±co:
			<pre>			  fix (fun f -&gt; fun n -&gt; if n = 0 then 1 else n * (f (n-1)))
			</pre>
		      </li><li>
			Nie u¿ywaj±c rekursji (tj. konstrukcji <tt>let
			rec</tt>) zdefiniuj funkcjê obliczaj±c± silniê
			(u¿yj referencji).  W podobny sposób zdefiniuj
			funkcjê <tt>fix</tt>.
		    </li></ol>
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ II (na 05.12.2013)
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 2 (2p.)</h4> Rozwa¿my modyfikowalne listy zdefiniowane nastêpuj±co:
		    <pre>		      type 'a list_mutable = LMnil | LMcons of 'a * 'a list_mutable ref
		    </pre>
		    Zaimplementuj konkatenacjê list typu <tt>'a list_mutable</tt> na dwa sposoby:
		    <ol>
		      <li> funkcja <tt>concat_copy</tt> buduje listê wynikow± kopiuj±c pierwszy argument;
		      </li><li> funkcja <tt>concat_share</tt> buduje listê wynikow± bez kopiowania argumentów.
		    </li></ol>
		  </td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 3 (4p.)</h4>  Technika memoizacji
		    pozwala wykorzystaæ cechy imperatywne jêzyka w
		    celu zwiêkszenia efektywno¶ci dzia³ania funkcji,
		    która sama jest czysto funkcyjna, tj. kolejne
		    wywo³anie takiej funkcji dla tego samego argumentu
		    zwróci tê sam± warto¶æ. Memoizacja polega na
		    zapamiêtywaniu warto¶ci wywo³añ funkcji dla
		    konkretnych argumentów w pewnej strukturze danych,
		    i na wyszukiwaniu potrzebnych warto¶ci przy
		    kolejnych wywo³aniach tej funkcji.

		    Aby umo¿liwiæ memoizacjê dowolnej
		    jednoargumentowej funkcji, zaimplementuj
		    nastêpuj±cy schemat:
		    <ul>
		      <li>
			zdefiniuj typ polimorficzny s³u¿±cy jako tablica warto¶ci
			wywo³añ dowolnej funkcji;
		      </li>
		      <li>
			napisz funkcjê tworzenia pustej tablicy;
		      </li>
		      <li>
			napisz funkcjê wyszukiwania w tablicy warto¶ci funkcji dla
			zadanego argumentu;
		      </li>
		      <li>
			napisz funkcjê dopisuj±c± do tablicy now± warto¶æ wywo³ania funkcji.
		      </li>
		    </ul>
		    <br>
		    Wykorzystaj ten schemat do memoizacji funkcji wyznaczaj±cej kolejne
		    liczby Fibonacciego: napisz funkcjê <tt>fib : int -&gt; int</tt> wed³ug
		    standardowej definicji oraz funkcjê <tt>fib_memo : int -&gt; int</tt> wykorzystuj±c±
		    memoizacjê.  Porównaj czasy wykonania obu funkcji.
		    <br>
		    Czy funkcja <tt>fib_memo</tt> spe³nia Twoje oczekiwania w kwestii
		    efektywno¶ci? Zmodyfikuj schemat memoizacji dla tej funkcji, aby
		    maksymalnie wykorzystaæ tê technikê.
		  </td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 4 (2p.)</h4>  Napisz
		    funkcjê <tt>fresh</tt> typu <tt>string -&gt;
		    string</tt> generuj±c± ¶wie¿e nazwy, której
		    kolejne wywo³ania maj± nastêpuj±cy efekt:
		    <pre># fresh "x";;
- : string = "x1"
# fresh "x";;
- : string = "x2"
# fresh "x";;
- : string = "x3"
# fresh "y";;
- : string = "y4"
		    </pre>
		    itd... oraz funkcjê <tt>reset</tt> typu <tt>int -&gt; unit</tt>, która ustawia pocz±tkow± warto¶æ
		    generowanego indeksu dla nastêpnych wywo³añ funkcji <tt>fresh</tt>, np.
		    <pre># fresh "x";;
- : string = "x1"
# fresh "x";;
- : string = "x2"
# reset 5;;
- : unit = ()
# fresh "x";;
- : string = "x6"
# fresh "x";;
- : string = "x7"
		    </pre>   
		    Uwaga! Funkcje nie mog± wykorzystywaæ ¿adnych zmiennych globalnych.  
		  </td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 5 (2p.)</h4>
		    Rozwi±¿ problem Józefa, tj. zadanie 4 z listy kontrolnej do wyk³adu 6.
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
      </tbody>
    </table>
  

</body></html>